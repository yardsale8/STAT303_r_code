Introduction to R
========================================================
author: 
date: 
autosize: true

Why use R?
========================================================

- Save and rerun code
- Lots of stats/data science packages
- Great graphics
- Built for data
- free, open source, cross-platform
- Large community

Market-share
========================================================

![](Fig-1a-IndeedJobs-2017.png)

Why RStudio?
========================================================

- Adds *quality of life* improvements
  - Code completion
  - Variable explorer
  - Keyboard shortcuts
- Adds more advanced file-types
  - Rmarkdown
  - Rpresentation
  
More about RStudio
========================================================

![](RStudio.png)
  
Interacting with R
========================================================

- **Ctrl/Cmd + Enter** to run code
- **Ctrl + 1** and **Ctrl + 2** switches between script and console

Getting Help
========================================================

```{r}
?barplot
args(lm)
??kruskal
```

Evaluating Expression in the Console
========================================================

```{r}
3 + 5
12 / 7
```

Saving and Retrieving a Value
========================================================

```{r}
weight_kg <- 55
weight_kg
```

Using Variables in Expressions
========================================================

```{r}
# A variable in an expression
2.2 * weight_kg
# The value didn't change
weight_kg
```

Using Variables in Expressions
========================================================
```{r}
# Changing the value
weight_kg <- 57.5
2.2 * weight_kg
# Creating a new variable
weight_lb <- 2.2 * weight_kg
weight_lb
```

Challenge
========================================================

What are the values after each statement in the following?
```{r}
mass <- 47.5            # mass?
age  <- 122             # age?
mass <- mass * 2.0      # mass?
age  <- age - 20        # age?
mass_index <- mass/age  # mass_index?

```

Calling functions
========================================================

```{r}
a <- 2
b <- sqrt(a)
b
round(3.14159)
```

More on calling functions
========================================================

```{r}
# Changing a default value
args(round)
round(3.14159, digits = 2)
```

More ways to provide arguments
========================================================
```{r}
args(round)
# Pass arguments by position
round(3.14159, 2)
# Pass arguments using name = value (order doesn't matter)
round(digits = 2, x = 3.14159)
```

Vectors
========================================================

- Used to store an ordered sequence
- 6 basic types
  - character
  - numeric
  - logical
  - integer
  - complex
  - raw
  
Vector Examples
========================================================

```{r}
weight_g <- c(50, 60, 65, 82)
weight_g
animals <- c("mouse", "rat", "dog")
animals
```

Vector Examples
========================================================

```{r}
length(weight_g)
class(weight_g)
str(weight_g)
```

Adding to a Vector with `c`
========================================================

```{r}
weight_g <- c(weight_g, 90) # add to the end of the vector
weight_g <- c(30, weight_g) # add to the beginning of the vector
weight_g
```

Challenge - Mixing Data Types
========================================================

Look at the classes of the following vectors.

```{r}
num_char <- c(1, 2, 3, 'a')
num_logical <- c(1, 2, 3, TRUE)
char_logical <- c('a', 'b', 'c', TRUE)
tricky <- c(1, 2, 3, '4')
```

Sub-setting Vectors
========================================================

```{r}
animals <- c("mouse", "rat", "dog", "cat")
# R indexes starting at 1!
animals[2]
animals[c(3, 2)]
more_animals <- animals[c(1, 2, 3, 2, 1, 4)]
more_animals
```

Conditional Sub-setting
========================================================

```{r}
weight_g <- c(21, 34, 39, 54, 55)
weight_g[c(TRUE, FALSE, TRUE, TRUE, FALSE)]
```

Conditional Sub-setting
========================================================

```{r}
weight_g > 50
weight_g[weight_g > 50]
```

Conditional Sub-setting
========================================================

```{r}
weight_g[weight_g < 30 | weight_g > 50]
weight_g[weight_g >= 30 & weight_g == 21]
```

Checking if a value is **in** a collection
========================================================

```{r}
animals %in% c("rat", "cat", "dog", "duck", "goat")
animals[animals %in% c("rat", "cat", "dog", "duck", "goat")]
```

Be your own interpreter! (How to think like R)
========================================================

- Work *inside out*
- Evaluate the inner most expression
- Replace code with a value

Be your own interpreter! (How to think like R)
========================================================

```{r}
# Original expression
animals[animals %in% c("rat", "cat", "dog", "duck", "goat")]
# Inner-most expression
animals
# Replace animals with its value
c("mouse", "rat", "dog", "cat") %in% c("rat", "cat", "dog", "duck", "goat")
```


Review of Expressions and Interpreter
========================================================

- An expression is code with value
- An interpreter converts expressions to values
- Learn R == Learning to think like R
  - Be your own interpreter
  

Be your own interpreter! (How to think like R)
========================================================

```{r}
# Move out, replacing the inner expression with its value
animals[animals %in% c("rat", "cat", "dog", "duck", "goat")]
animals[c(FALSE, TRUE, TRUE, TRUE)]
c("mouse", "rat", "dog", "cat")[c(FALSE, TRUE, TRUE, TRUE)]
```

Challenge (optional)
========================================================

Can you figure out why `"four" > "five"` returns TRUE?

```{r}
"four" > "five"
```

Missing Values
========================================================

- Real data as missing values
- R is designed for real data
- `NA` is a missing value

Computing with Missing Values
========================================================

```{r}
heights <- c(2, 4, 4, NA, 6)
mean(heights)
mean(heights, na.rm = TRUE)
```

Removing `NA`s
========================================================

```{r}
## Extract those elements which are not missing values.
heights[!is.na(heights)]
```

Be your own interpreter
========================================================
Explore the following expression.

```{r}
heights <- c(2, 4, 4, NA, 6)
heights[!is.na(heights)]
```

Removing `NA`s
========================================================

```
## Returns the object with incomplete cases removed. The returned object is atomic.
na.omit(heights)

## Extract those elements which are complete cases.
heights[complete.cases(heights)]

```

Reading files
========================================================

```{r eval=FALSE}
# Navigate to the file
surveys <- read.csv( file.choose() )
```
```{r}
# Using a path
surveys <- read.csv('data/portal_data_joined.csv', # The path
                    header=TRUE, # This file has a header
                    sep=",") # How data is separated
```

Viewing a data frame
========================================================

```{r}
head(surveys)
```



What is a data frame
========================================================

* A collection of named columns
  * Column == vector
  * Standard vector types


Structure of a data frame
========================================================

```{r}
str(surveys)
```

Other data frame inspection tools - Size
========================================================

* `dim(surveys)` - returns a vector with 
  * the number of rows in the first element, and 
  * the number of columns as the second element (the dimensions of the object)
* `nrow(surveys)` - returns the number of rows
* `ncol(surveys)` - returns the number of columns

Other data frame inspection tools - Content
========================================================

  * `head(surveys)` - shows the first 6 rows
  * `tail(surveys)` - shows the last 6 rows
  
Other data frame inspection tools - Names
========================================================

* `names(surveys)` - returns the column names 
  * synonym of `colnames()`
* `rownames(surveys)` - returns the row names

Other data frame inspection tools - Summary
========================================================

* `str(surveys)` - structure of the object and information about the class, length and content of each column
* `summary(surveys)` - summary statistics for each column

Challenge
========================================================
Based on the output of `str(surveys)`, can you answer the following questions?

* What is the class of the object surveys?
* How many rows and how many columns are in this object?
* How many species have been recorded during these surveys

Getting data from a data frame - Indexing
========================================================

Try each of the following
```{r eval=FALSE}
surveys[1, 1]   # first element in the first column of the data frame (as a vector)
surveys[1, 6]   # first element in the 6th column (as a vector)
surveys[, 1]    # first column in the data frame (as a vector)
surveys[1]      # first column in the data frame (as a data.frame)
surveys[1:3, 7] # first three elements in the 7th column (as a vector)
surveys[3, ]    # the 3rd element for all columns (as a data.frame)
head_surveys <- surveys[1:6, ] # equivalent to head(surveys)
```

Excluding values with `-`
========================================================

```{r eval=FALSE}
surveys[,-1]          # The whole data frame, except the first column
surveys[-c(7:34786),] # Equivalent to head(surveys)
```

Using column names
========================================================

```{r eval=FALSE}
surveys["species_id"]       # Result is a data.frame
surveys[, "species_id"]     # Result is a vector
surveys[["species_id"]]     # Result is a vector
surveys$species_id          # Result is a vector
```

Challenge
========================================================

* Create a data.frame (surveys_200) containing only the observations from row 200 of the surveys data set.
* Notice how nrow() gave you the number of rows in a data.frame?

  * Use that number to pull out just that last row in the data frame.
  * Compare that with what you see as the last row using tail() to make sure itâ€™s meeting expectations.
  * Pull out that last row using nrow() instead of the row number.
  * Create a new data frame object (surveys_last) from that last row.
* Use nrow() to extract the row that is in the middle of the data frame. Store the content of this row in an object named surveys_middle.
* Combine nrow() with the - notation above to reproduce the behavior of head(surveys) keeping just the first through 6th rows of the surveys data set.

What is `dpylr` and `tidyverse`?
========================================================

- Package for managing and manipulating data
- Consists of
  - `dpylr`
    - filter
    - make new columns
    - aggregate
  - `tildr`
    - Fix data and apply golden rule
  - `ggplot`
    - Nice graphics
    
    
Installing `tidyverse`
========================================================

```{r eval=FALSE}
# Only need to do this once
# Time consuming!
install.packages("tidyverse")
```

Loading a Library
========================================================

```{r}
# This loads all of the dpylr functions
library("dplyr")
```

Selecting columns with `select`
========================================================

```{r}
# Syntax: select(df, col1, col2, ...)
new_df <- select(surveys, plot_id, species_id, weight)

# Good habit: Always inspect the result with head
head(new_df)
```

Selecting rows with `filter`
========================================================

```{r}
new_df2 <- filter(surveys, year == 1995)
head(new_df2)
# Why are there columns not select (last slide) still here?
```

Making a new column with `mutate`
========================================================

```{r}
new_df <- select(surveys, plot_id, species_id, weight, year)
new_df2 <- filter(new_df, year == 1995)
new_df3 <- mutate(new_df2, weight_kg = weight / 1000)
head(new_df3)
```

Fundamental `dyplr`/functional principles
========================================================

- data frame in, data frame out
- returns a **new** data frame
  - no mutation

Imperative pattern - Save, save, save
========================================================

![](./imperative_pattern.png)
- **Problem 1:** Lots of temporary variables
- **Problem 2:** Messy and lots of *overhead*
  - All the extra *stuff* clouds the meaning/intent of the code

Poor solution - Rewrite to the same data frame
========================================================

```{r eval=FALSE}
# What is wrong with this approach?
surveys <- select(surveys, plot_id, species_id, weight, year)
surveys <- filter(surveys, year == 1995)
surveys <- mutate(surveys, weight_kg = weight / 1000)
head(surveys)
```

Use a pipe for cleaner code
========================================================

```{r}
surveys  %>% 
  select(         plot_id, species_id, weight, year) %>%
  filter(         year == 1995) %>%
  mutate(         weight_kg = weight / 1000) %>%
  head(           )
```

Pipe pushes the data frame through the first position
========================================================

![](./pipe1.png)

Imagine an invisible data frame in the first spot
========================================================

```{r}
surveys  %>% 
  select(#surveys,      
                      plot_id, species_id, weight, year) %>%
  filter(#df_sel,
                      year == 1995) %>%
  mutate(#df_sel_filt,     
                      weight_kg = weight / 1000) %>%
  head(#df_sel_filt_mutate        
       )
```

Important Point - Each data frame is NEW
========================================================

![](./pipe2.png)


Imagine the missing data frame ... but don't write it!
========================================================

```{r}
surveys  %>% 
  select(plot_id, species_id, weight, year) %>%
  filter(year == 1995) %>%
  mutate(weight_kg = weight / 1000) %>%
  head()
```

Saving the result of a piped operation
========================================================

```{r}
surveys_small <- surveys %>%
  filter(weight < 5) %>%
  select(species_id, sex, weight)

head(surveys_small)
```

Challenge
========================================================

Create a new data frame from the surveys data that meets the following criteria: 

- contains only the **`species_id`** column and 
- a new column called  **`hindfoot_half`** 
  - values that are half the **`hindfoot_length`** values. 
- **`hindfoot_half`** column has 
  - no `NA`s and 
  - all values are less than 30.

Hint: think about how the commands should be ordered to produce this data frame!





